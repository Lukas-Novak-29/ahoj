<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webkamera s inteligentním AI zoomem</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            gap: 20px;
        }
        .container {
            position: relative;
        }
        #webcam-canvas {
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            max-width: 90%;
            background-color: black;
            max-height: 70vh;
            cursor: crosshair;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        input[type="range"] {
            width: 150px;
        }
        button, label, select {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            transition: background-color 0.3s;
        }
        button:hover, label:hover, select:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #start-recording-btn, #stop-recording-btn {
            background-color: #333;
            color: white;
        }
        #start-recording-btn:hover, #stop-recording-btn:hover {
            background-color: #111;
        }
        .recording-indicator {
            width: 15px;
            height: 15px;
            background-color: red;
            border-radius: 50%;
            display: none;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
</head>
<body>
    <div class="container">
        <canvas id="webcam-canvas"></canvas>
    </div>
    <div class="controls">
        <button id="start-recording-btn">Nahrávat</button>
        <button id="stop-recording-btn" disabled>Zastavit nahrávání</button>
        <button id="switch-camera-btn">Přepnout kameru</button>
        <div class="control-group">
            <label for="zoom-slider">Zoom (1x - 4x):</label>
            <input type="range" id="zoom-slider" min="1.0" max="4.0" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label for="margin-slider">Okraj (1.0 - 10.0):</label>
            <input type="range" id="margin-slider" min="1.0" max="10.0" step="0.1" value="3.5">
        </div>
        <div class="control-group">
            <label for="ease-slider">Plynulost (0.1 - 1.0):</label>
            <input type="range" id="ease-slider" min="0.1" max="1.0" step="0.05" value="0.25">
        </div>
        <label for="object-selector">Sledovat:</label>
        <select id="object-selector">
            <option value="person">Člověk</option>
            <option value="dog">Pes</option>
            <option value="cat">Kočka</option>
            <option value="car">Auto</option>
            <option value="ball">Florbalový míč</option>
            <option value="none">Žádný</option>
            <option value="manual">Manuálně</option>
        </select>
        <button id="select-object-btn">Vybrat objekt</button>
        <div id="recording-status" class="recording-indicator"></div>
    </div>
    <video id="hidden-video" style="display: none;"></video>
    <script>
        const canvas = document.getElementById('webcam-canvas');
        const context = canvas.getContext('2d', { willReadFrequently: true });
        const hiddenVideo = document.getElementById('hidden-video');
        const startBtn = document.getElementById('start-recording-btn');
        const stopBtn = document.getElementById('stop-recording-btn');
        const switchBtn = document.getElementById('switch-camera-btn');
        const objectSelector = document.getElementById('object-selector');
        const selectObjectBtn = document.getElementById('select-object-btn');
        const zoomSlider = document.getElementById('zoom-slider');
        const marginSlider = document.getElementById('margin-slider');
        const easeSlider = document.getElementById('ease-slider');
        const recordingStatus = document.getElementById('recording-indicator');

        let mediaRecorder;
        let recordedChunks = [];
        let currentStream;
        let videoInputs = [];
        let currentCameraIndex = 0;
        let model = null;

        let trackedObject = null;
        let trackedObjectInfo = null;
        let targetZoom = 1.0;
        let targetPanX = 0;
        let targetPanY = 0;
        let currentZoom = 1.0;
        let currentPanX = 0;
        let currentPanY = 0;
        let EASE_FACTOR = 0.25;
        const MAX_ZOOM = 4.0;
        const MIN_ZOOM = 1.0;
        let frameCount = 0;
        const detectionFrameInterval = 5; // AI detekce na každém 5. snímku

        async function loadModel() {
            try {
                model = await cocoSsd.load();
                console.log('AI model načten.');
                startRendering();
            } catch (error) {
                console.error('Nepodařilo se načíst AI model:', error);
            }
        }

        async function getStream(deviceId) {
            try {
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }
                const constraints = {
                    video: {
                        deviceId: deviceId ? { exact: deviceId } : undefined,
                        width: { ideal: 1280, min: 640 },
                        height: { ideal: 720, min: 480 },
                        frameRate: { ideal: 60, min: 30 }
                    }
                };
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                hiddenVideo.srcObject = currentStream;
                startBtn.disabled = false;

                hiddenVideo.onloadedmetadata = () => {
                    const aspectRatio = hiddenVideo.videoWidth / hiddenVideo.videoHeight;
                    const containerWidth = canvas.parentNode.offsetWidth;
                    const newCanvasHeight = containerWidth / aspectRatio;
                    canvas.width = containerWidth;
                    canvas.height = newCanvasHeight;
                    hiddenVideo.play();
                    
                    currentZoom = 1.0;
                    currentPanX = hiddenVideo.videoWidth / 2;
                    currentPanY = hiddenVideo.videoHeight / 2;
                };
            } catch (error) {
                console.error('Přístup ke kameře byl odmítnut nebo nastala chyba:', error);
                alert('Přístup ke kameře byl zamítnut nebo nastala chyba. Zkontrolujte, zda jste aplikaci povolili přístup.');
            }
        }

        async function getCameras() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                alert('Váš prohlížeč nepodporuje výčet zařízení.');
                return;
            }
            const devices = await navigator.mediaDevices.enumerateDevices();
            videoInputs = devices.filter(device => device.kind === 'videoinput');
            
            const rearCamera = videoInputs.find(device => device.label.toLowerCase().includes('back') || device.label.toLowerCase().includes('zadni'));
            if (rearCamera) {
                currentCameraIndex = videoInputs.indexOf(rearCamera);
            }

            if (videoInputs.length > 1) {
                switchBtn.style.display = 'inline-block';
            } else {
                switchBtn.style.display = 'none';
            }
        }

        function startRendering() {
            requestAnimationFrame(renderLoop);
        }

        function startRecording() {
            recordedChunks = [];
            const canvasStream = canvas.captureStream(60); 
            mediaRecorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm' });
            mediaRecorder.ondataavailable = event => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                document.body.appendChild(a);
                a.style = 'display: none';
                a.href = url;
                a.download = 'nahravka.webm';
                a.click();
                window.URL.revokeObjectURL(url);
            };
            mediaRecorder.start();
            startBtn.disabled = true;
            stopBtn.disabled = false;
            recordingStatus.style.display = 'block';
            console.log('Nahrávání zahájeno...');
        }

        function stopRecording() {
            mediaRecorder.stop();
            startBtn.disabled = false;
            stopBtn.disabled = true;
            recordingStatus.style.display = 'none';
            console.log('Nahrávání zastaveno. Stahuji video...');
        }

        function switchCamera() {
            if (videoInputs.length < 2) return;
            currentCameraIndex = (currentCameraIndex + 1) % videoInputs.length;
            const nextCameraId = videoInputs[currentCameraIndex].deviceId;
            getStream(nextCameraId);
        }

        function renderLoop() {
            const videoWidth = hiddenVideo.videoWidth;
            const videoHeight = hiddenVideo.videoHeight;
            
            currentZoom += (targetZoom - currentZoom) * EASE_FACTOR;
            currentPanX += (targetPanX - currentPanX) * EASE_FACTOR;
            currentPanY += (targetPanY - currentPanY) * EASE_FACTOR;

            const sourceWidth = videoWidth / currentZoom;
            const sourceHeight = videoHeight / currentZoom;
            const sourceX = Math.max(0, Math.min(videoWidth - sourceWidth, currentPanX - sourceWidth / 2));
            const sourceY = Math.max(0, Math.min(videoHeight - sourceHeight, currentPanY - sourceHeight / 2));

            context.clearRect(0, 0, canvas.width, canvas.height);
            if (hiddenVideo.readyState >= 2) {
                context.drawImage(hiddenVideo, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, canvas.width, canvas.height);
            }
            
            if (trackedObject) {
                const [x, y, width, height] = trackedObject.bbox;
                const canvasX = (x - sourceX) * (canvas.width / sourceWidth);
                const canvasY = (y - sourceY) * (canvas.height / sourceHeight);
                const canvasWidth = width * (canvas.width / sourceWidth);
                const canvasHeight = height * (canvas.height / sourceHeight);

                context.beginPath();
                context.rect(canvasX, canvasY, canvasWidth, canvasHeight);
                context.lineWidth = 2;
                context.strokeStyle = 'red';
                context.stroke();
                
                context.font = '16px Arial';
                context.fillStyle = 'red';
                context.fillText(`${trackedObject.class} (${Math.round(trackedObject.score * 100)}%)`, canvasX, canvasY > 10 ? canvasY - 5 : 10);
            }

            if (frameCount % detectionFrameInterval === 0) {
                detectObjects();
            }
            frameCount++;
            requestAnimationFrame(renderLoop);
        }

        async function detectObjects() {
            if (!model || hiddenVideo.readyState < 2) return;
            const predictions = await model.detect(hiddenVideo);
            const selectedObject = objectSelector.value;

            if (selectedObject === "none") {
                trackedObject = null;
                trackedObjectInfo = null;
                targetZoom = parseFloat(zoomSlider.value);
                targetPanX = hiddenVideo.videoWidth / 2;
                targetPanY = hiddenVideo.videoHeight / 2;
            } else if (selectedObject === "manual") {
                if (trackedObjectInfo) {
                    const [x, y, width, height] = trackedObjectInfo.bbox;
                    const currentBestMatch = predictions
                        .filter(p => p.class === trackedObjectInfo.class)
                        .sort((a, b) => {
                            const aDist = Math.sqrt(Math.pow(a.bbox[0] - x, 2) + Math.pow(a.bbox[1] - y, 2));
                            const bDist = Math.sqrt(Math.pow(b.bbox[0] - x, 2) + Math.pow(b.bbox[1] - y, 2));
                            return aDist - bDist;
                        })[0];
                    
                    trackedObject = currentBestMatch;
                    if (trackedObject) {
                        trackedObjectInfo = trackedObject;
                        updateZoomAndPan();
                    } else {
                        targetZoom = parseFloat(zoomSlider.value);
                        targetPanX = hiddenVideo.videoWidth / 2;
                        targetPanY = hiddenVideo.videoHeight / 2;
                    }
                }
            } else {
                const bestPrediction = predictions
                    .filter(p => p.class === selectedObject)
                    .sort((a, b) => b.score - a.score)[0];
                trackedObject = bestPrediction;
                if (trackedObject) {
                    updateZoomAndPan();
                } else {
                    targetZoom = parseFloat(zoomSlider.value);
                    targetPanX = hiddenVideo.videoWidth / 2;
                    targetPanY = hiddenVideo.videoHeight / 2;
                }
            }
        }

        function updateZoomAndPan() {
            if (!trackedObject) return;
            const [x, y, width, height] = trackedObject.bbox;
            const margin = parseFloat(marginSlider.value);
            const videoWidth = hiddenVideo.videoWidth;
            const videoHeight = hiddenVideo.videoHeight;
            const boxAspect = width / height;
            const videoAspect = videoWidth / videoHeight;

            let newZoom;
            if (boxAspect > videoAspect) {
                newZoom = videoWidth / (width * margin);
            } else {
        
                newZoom = videoHeight / (height * margin);
            }

            targetZoom = Math.min(Math.max(newZoom, MIN_ZOOM), MAX_ZOOM);
            targetPanX = x + width / 2;
            targetPanY = y + height / 2;
        }

        function findClosestObject(x, y) {
            if (!model || hiddenVideo.readyState < 2) return;
            model.detect(hiddenVideo).then(predictions => {
                let minDistance = Infinity;
                let closestPrediction = null;
                const videoWidth = hiddenVideo.videoWidth;
                const videoHeight = hiddenVideo.videoHeight;

                predictions.forEach(p => {
                    const [objX, objY, objW, objH] = p.bbox;
                    const centerX = (objX + objW / 2);
                    const centerY = (objY + objH / 2);
                    
                    const dist = Math.sqrt(Math.pow(centerX - x, 2) + Math.pow(centerY - y, 2));
                    if (dist < minDistance) {
                        minDistance = dist;
                        closestPrediction = p;
                    }
                });

                if (closestPrediction) {
                    trackedObject = closestPrediction;
                    trackedObjectInfo = {
                        class: closestPrediction.class,
                        bbox: closestPrediction.bbox
                    };
                    updateZoomAndPan();
                }
            });
        }

        window.onload = () => {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                loadModel();
                getCameras().then(() => {
                    getStream(videoInputs[currentCameraIndex]?.deviceId);
                });
            } else {
                alert('Váš prohlížeč nepodporuje přístup ke kameře.');
            }
        };

        startBtn.addEventListener('click', startRecording);
        stopBtn.addEventListener('click', stopRecording);
        switchBtn.addEventListener('click', switchCamera);
        zoomSlider.addEventListener('input', () => {
            if (objectSelector.value === "none" || objectSelector.value === "manual") {
                targetZoom = parseFloat(zoomSlider.value);
            }
        });
        marginSlider.addEventListener('input', () => {
             if (trackedObject) {
                 updateZoomAndPan();
             } else {
                 targetZoom = parseFloat(zoomSlider.value);
             }
        });
        easeSlider.addEventListener('input', (event) => {
             EASE_FACTOR = parseFloat(event.target.value);
        });
        objectSelector.addEventListener('change', () => {
            if (objectSelector.value === "manual" || objectSelector.value === "none") {
                selectObjectBtn.disabled = objectSelector.value !== "manual";
                if (objectSelector.value === "none") {
                    trackedObject = null;
                    trackedObjectInfo = null;
                    targetZoom = parseFloat(zoomSlider.value);
                    targetPanX = hiddenVideo.videoWidth / 2;
                    targetPanY = hiddenVideo.videoHeight / 2;
                }
            } else {
                selectObjectBtn.disabled = true;
                trackedObjectInfo = null;
            }
        });
        selectObjectBtn.addEventListener('click', () => {
            canvas.style.cursor = 'crosshair';
            canvas.onclick = (event) => {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const videoX = (x / canvas.width) * hiddenVideo.videoWidth;
                const videoY = (y / canvas.height) * hiddenVideo.videoHeight;

                findClosestObject(videoX, videoY);
                canvas.style.cursor = 'default';
                canvas.onclick = null;
            };
        });
    </script>
</body>
</html>
